# HashMap


HashMap是键值对列表，是以数组+链表的形式实现的。
不指定初始容量的话，初始容量是16。当元素个数大于容量的0.75倍时，扩容到当前容量的2倍。
存储数据时，用HahMap的hash方法计算元素的hash值，然后根据hash值计算index，将元素存储到index位置即可，如果当前位置有数据（也就是碰到了传说中的哈希碰撞，应该不同于真正的哈希碰撞，因为这里只有后几位相同而已，原因且看后面hash的分析），则将当前数据作为一个节点，存到该位置元素的后面，形成一条链表。


这么做的好处，插入，删除数据的时候，根据元素hash值找到index，将该位置对应链表的数据删除即可。查找数据的时候，找到key的hash值对应index位置的链表，再遍历较短的链表，即可找到目标。


如果初始化HashMap时，指定容量不为2的几次幂，则真正容量是计算出指定容量的下一个为2的幂的数，比如指定17，则真正容量其实是32。计算方法：
```
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```


这里的hash是怎么计算的？
```
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
计算得出的hash值，是用hashCode计算出的hash值的高16位与低16位进行异或。这么做是因为，16位长度的列表够用了，而且这么做之后，后几位hash碰撞的几率会降低。

得到hash值了，index是怎么计算的呢？
```
index = e.hash & (tab.length - 1);
```
这里的length肯定是2的幂，上面有说到。这样hash&(len-1)的时候，就是与上一个后几位全1的数，比如(00011111)，然后得到的结果就是hash值的后5位，并当作index。
全1了，&操作的结果就肯定和hash值的后几位一样了，不是全1的话，不一样的hash值，&的结果也有可能一样，导致分布不均。


Java8之后，当链表长度超过8之后，将当前链表转为红黑树，传说是为了更快查询，没研究为什么。
