线程状态
NEW
RUNNABLE        处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
BLOCKED         正在等待进入同步锁，或者在调用了object.wait方法并被唤醒后等待重新进入同步锁
WAITING         调用了无参的object.wait方法，或调用了无参的thread.join方法
TIMED_WAITING   调用了Thread.sleep方法，或者调用了有参的object.wait或者有参的thread.join
TERMINATED

join()方法是指等待调用join()方法的线程执行结束，程序才会继续执行下去
yield()方法是这样描述的：暂停当前正在执行的线程对象，并执行其他线程。在多线程的情况下，由CPU决定执行哪一个线程，而yield()方法就是暂停当前的线程，让给其他线程（包括它自己）执行，具体由谁执行由CPU决定。
sleep不让出cpu时间片，wait会让出cpu时间片


加锁方式
synchronized对一个对象或者一个类，或者一个方法，一个代码块加锁
ReentrantLock进行显示加锁，创建RL对象，调用lock，unlock方法
队列，将共享资源存到队列中，一个线程在使用资源时，就将资源在队列中取出，用完再放回队列，如果队列中没有资源，则阻塞队列。LinkedBlockingQueue里面的阻塞就是用ReentrantLock实现的。
actomicInteger原子变量

gc,引起gc的原因
不断io，io阻塞，io操作都是什么


每个CPU在同一时间只能执行一个线程，Linux采用的是抢占式调度，即为每个线程分配一定的执行时间，当到达执行时间、线程中有IO阻塞或高级优先线程要执行时，Linux将切换执行线程，在切换时要存储目前线程的执行状态，并要恢复要执行的线程状态，这个过程称为上下文切换
对于java应用，典型的是进行文件IO操作、网络IO操作、锁等待或线程sleep时，当前线程会进入阻塞或休眠状态，从而促发上下文切换，上下文切换过多会造成内核占据较多的CPU使用，使得应用的相应速度下降。

java应用造成us高的原因主要是线程一直处于可运行状态，通常是这些线程在执行无阻塞、循环、正则或纯粹的计算等动作造成；另外一个可能是频繁GC。如每次请求都需要分配较多的内存，当访问量高的时候就将导致不断地进行GC，系统响应速度下降，进而造成堆积的请求更多，消耗的内存更严重，最严重的时候有可能会导致系统不断的惊醒Full GC，对于频繁GC的状况要通过分析JVM内存消耗来查找原因

当sy值高时，表示Linux花费了更多的时间在进行线程切换，Java应用造成这种现象的主要原因是启动的线程比较多，且这些线程多数处理不断的阻塞（如锁等待、IO等待状态）和执行状态的编号过程中，这就导致了操作系统要不断切换执行的线程，产生大量的上下文切换。在这种状况下，对Java应用，最重要的是找出线程不断切换状态的原因。
